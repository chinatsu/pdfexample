/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package pdfexample

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder
import com.openhtmltopdf.pdfboxout.PdfRendererBuilder
import org.apache.pdfbox.io.IOUtils
import org.apache.pdfbox.pdmodel.PDDocument
import org.apache.pdfbox.pdmodel.PDPage
import org.apache.pdfbox.pdmodel.common.PDMetadata
import org.apache.pdfbox.pdmodel.common.PDRectangle
import org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDMarkInfo
import org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot
import org.apache.pdfbox.pdmodel.graphics.color.PDOutputIntent
import org.apache.pdfbox.pdmodel.interactive.viewerpreferences.PDViewerPreferences
import org.apache.xmpbox.XMPMetadata
import org.apache.xmpbox.type.BadFieldValueException
import org.apache.xmpbox.xml.XmpSerializer
import org.verapdf.pdfa.Foundries
import org.verapdf.pdfa.VeraGreenfieldFoundryProvider
import org.verapdf.pdfa.flavours.PDFAFlavour
import org.verapdf.pdfa.results.TestAssertion
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.InputStream
import java.lang.IllegalArgumentException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.*
import kotlin.streams.toList

typealias Document = Pair<String, String>

val fontsRoot: Path = Paths.get("fonts/")
val documentsRoot: Path = Paths.get("documents/")

val objectMapper: ObjectMapper = ObjectMapper()
    .registerKotlinModule()

val fonts: List<FontMetadata> = objectMapper.readValue(Files.newInputStream(fontsRoot.resolve("config.json")))
val colorProfile: ByteArray = IOUtils.toByteArray(PDDocument::class.java.getResourceAsStream("/sRGB2014.icc"))


fun main() {
    VeraGreenfieldFoundryProvider.initialise()
    Files.list(documentsRoot)
        .map { it.fileName.toString().split('.').first() to Files.readAllBytes(it).toString(Charsets.UTF_8) }
        .toList()
        .forEach(Document::makePdf)
}

fun Document.makePdf() {
    val name = this.first
    val doc = this.second
    println("\nCreating PDF from $name.html")
    val outputStream = ByteArrayOutputStream()

    val renderer = PdfRendererBuilder()
        .apply {
            for (font in fonts) {
                useFont({ ByteArrayInputStream(font.bytes) }, font.family, font.weight, font.style, font.subset)
            }
        }
        .usePdfAConformance(PdfRendererBuilder.PdfAConformance.PDFA_2_U)
        .useColorProfile(colorProfile)
        .withHtmlContent(doc, null)
        .buildPdfRenderer()

    renderer.createPDFWithoutClosing()
    //renderer.pdfDocument.conform()
    renderer.pdfDocument.save(outputStream)
    renderer.pdfDocument.close()

    val pdf = outputStream.toByteArray()

    println("PDF/A-2U compliant: ${verifyCompliance(pdf)}")

    File("$name.pdf").writeBytes(pdf)
}


fun PDDocument.conform() {
    val xmp = XMPMetadata.createXMPMetadata()
    val catalog = this.documentCatalog
    val cal = Calendar.getInstance()
    val page = PDPage(PDRectangle.A4)

    try {
        val dc = xmp.createAndAddDublinCoreSchema()
        dc.addCreator("pdfgen")
        dc.addDate(cal)

        val id = xmp.createAndAddPFAIdentificationSchema()
        id.part = 2
        id.conformance = "U"

        val serializer = XmpSerializer()
        val baos = ByteArrayOutputStream()
        serializer.serialize(xmp, baos, true)

        val metadata = PDMetadata(this)
        metadata.importXMPMetadata(baos.toByteArray())
        catalog.metadata = metadata
    } catch (e: BadFieldValueException) {
        throw IllegalArgumentException(e)
    }

    val intent = PDOutputIntent(this, colorProfile.inputStream())
    intent.info = "sRGB IEC61966-2.1"
    intent.outputCondition = "sRGB IEC61966-2.1"
    intent.outputConditionIdentifier = "sRGB IEC61966-2.1"
    intent.registryName = "http://www.color.org"
    catalog.addOutputIntent(intent)
    catalog.language = "en-US"

    val pdViewer = PDViewerPreferences(page.cosObject)
    pdViewer.setDisplayDocTitle(true)
    catalog.viewerPreferences = pdViewer

    catalog.markInfo = PDMarkInfo(page.cosObject)
    catalog.structureTreeRoot = PDStructureTreeRoot()
    catalog.markInfo.isMarked = true
}

fun verifyCompliance(input: ByteArray, flavour: PDFAFlavour = PDFAFlavour.PDFA_2_U): Boolean {
    val pdf = ByteArrayInputStream(input)
    val validator = Foundries.defaultInstance().createValidator(flavour, false)
    val result = Foundries.defaultInstance().createParser(pdf).use { validator.validate(it) }
    val failures = result.testAssertions
        .filter { it.status != TestAssertion.Status.PASSED }
    failures.forEach { test ->
        println(test.message)
        println("Location ${test.location.context} ${test.location.level}")
        println("Status ${test.status}")
        println("Test number ${test.ruleId.testNumber}")
    }
    return failures.isEmpty()
}

data class FontMetadata(
    val family: String,
    val path: String,
    val weight: Int,
    val style: BaseRendererBuilder.FontStyle,
    val subset: Boolean
) {
    val bytes: ByteArray = Files.readAllBytes(fontsRoot.resolve(path))
}
